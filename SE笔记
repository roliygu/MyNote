第一章 软件工程学概论
	软件系统本质上是信息处理系统
	软件=程序+数据+相关文档
	软件工程是:采用工程的概念,原理,技术和方法来开发和维护软件.
	软件危机:如何开发软件和如何维护数量不断膨胀的已有软件
	典型表现:
		对软件开发成本和进度估计不准确
		用户对"已完成"的软件系统不满意
		软件的质量低
		软件不可维护
		没有文档资料
		软件成本在总成本所占比例上升
		开发效率的提高跟不上计算机应用普及的速度
	软件危机的原因:
		软件本身的特点:缺乏"可见性",规模庞大等
		软件开发与维护的方法不正确:对用户要求没有完整准确的认识就着手编写程序是许多软件工程开发失败的主要原因
	软件工程方法学三个要素
		方法,工具和过程
		传统方法学:采用结构化技术来完成软件开发的各项任务
		面向对象方法学:
			面向对象方法=对象+类+继承+用消息通信
			用对象分解取代了传统方法的功能分解
		对象与传统数据的区别在于,对象是数据处理的主体,必须向它发送消息请求它执行它的某个操作以处理它的数据,而不能从外界直接对它的数据进行处理.尽量模拟人类的思维方式
	软件生命周期:
		软件定义时期:
			问题分析:要解决的问题是什么
			可行性研究:有解决的办法么
			需求分析:目标系统必须具备哪些功能
		开发时期:
			总体设计:怎样概括地实现目标系统;设计程序的体系结构:确定模块组成和模块间关系
			详细设计:设计出程序详细规格说明;详细地设计每个模块,确定模块功能所需要的算法和数据结构
			编码和单元测试
			综合测试:集成测试和验收测试
		维护时期:
			改正性维护:改正使用过程中发现的错误
			适应性维护:修改软件以适应新环境
			完善性维护:改进或扩充新功能
			预防性维护:修改软件,为未来做准备
	软件开发过程:
		瀑布模型(文档驱动模型):
			阶段间具有顺序性和依赖性:前一阶段结束才能继续
			推迟实现和质量保证的观点
			优点:强迫开发人员采用规范的方法,严格规定了每个阶段必须提交的文档,要求每个阶段都严格验证.
		快速原型(有助于保证用户的真是需求得到满足)
		增量模型:在较短时间内向用户提交部分工作的产品;逐步增加产品功能使用户容易学习.
		螺旋模型(使用原型及其他方法降低风险-风险驱动):
			对可选方案和约束条件的强调有利于已有软件的重用;
			减少了过多测试和测试不足带来的风险
			维护和开发之间没有本质区别
		喷泉模型(面向对象软件开发过程迭代和无缝的特性)
第二章 可行性研究
	用最小的代价确定问题是否能解决
	可行性包括:
		技术可行性
		经济可行性
		操作可行性
	可行性研究过程:
		复查系统规模和目标
		研究目前正在使用的系统
		导出新系统的高层逻辑模型
		进一步定义问题
		导出和评价供选择的解法
		推荐行动方针
		草拟开发计划
		书写文档提交审查
	系统流程图:
		矩形表示处理,平行四边形表示输入输出,圆柱表示磁盘
	数据流图:
		交流信息,分析和设计的工具
	数据字典,每个条目包括:名字,别名,描述,定义,位置
	成本/效益分析:减少运行费用或增加收入
		假设生命周期为5年
		将未来的钱换算成现在的价值
第三章 需求分析
	功能需求
	性能需求
	可靠性和可用性需求
	出错处理需求
	接口需求
	约束:设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件
	逆向需求:说明软件不需要做什么
	需求分析分别建立三种模型:
		数据模型(E-R图),功能模型(数据流图)和行为模型(状态转换图)
	数据模型(ER图):
		数据对象:
			对软件必须理解的复合信息的抽象,仅有单个值的事务不是数据对象
		属性:
			定义了数据对象的性质,必须把一个或多个属性定义为"标识符"
		联系
	行为模型(状态转换图):
		描绘系统的状态及引起系统状态转换的事件
		状态:
			只能有一个初态,0或多个终态
		事件:
			在某个特定时刻发生的事情,对引起系统做动作或从一个状态转换到另一个状态的外界事务的抽象
	验证软件需求:
		一致性,完整性,现实性和有效性
第五章 总体设计
	又称为概要设计或初步设计;目标是划分出组成系统的物理元素,设计软件的结构,即确定系统中每个程序是由那些模块组成,以及模块间的关系,分为两个阶段:
		系统设计阶段,确定系统的具体实现方案
		结构设计阶段,确定软件结构
	设计原理:
		模块化:
			过程,函数,子程序,宏,面向对象方法学中的对象和方法都可作为模块
			模块化使软件容易测试和调试,有助于提高软件的可靠性
		抽象:
			把相似的方面集中和概括起来,暂时忽略他们之间的差异;抽出事物的本质特性而暂时不考虑它们的细节
		逐步求精:
			为了能集中精力解决主要问题而尽量推迟对问题细节的考虑
			抽象和逐步求精是一对互补的概念
		信息隐藏和局部化:
			信息隐藏:一个模块内包含的信息对于不需要这些信息的模块来说是不能访问的
			局部化:使一些关系密切的软件元素物理地靠近
		模块独立:
			模块化,抽象,信息隐藏和局部化的直接结果
			独立性的理由:独立化的模块容易开发,测试和维护
			独立程度的测量:
				内聚:
					标志着一个模块内各个元素彼此结合的紧密程度
					低内聚:
						偶然内聚:一个模块完成那个一组任务,任务之间关系松散
						逻辑内聚:完成的任务在逻辑上属于相同或相似的一类
						时间内聚:任务必须在同一时间段内执行
					中内聚:
						过程内聚:处理的元素是相关的,而且必须以特定的次序执行(使用程序流程图得到的模块一般都满足)
						通信内聚:模块中所有元素都是用同一输入数据产生同一输出数据
					高内聚:
						顺序内聚:一个模块内的处理元素和同一个功能密切相关,且必须顺序执行(通过数据流图得到的模块一般满足)
						功能内聚:虽有处理元素都属于一个整体,完成单一的功能
				耦合:
					取决于模块间接口的复杂程度,进入或访问一个模块的点,以及通过接口的数据
					影响了系统的可理解性,可测试性,可靠性和可维护性
					数据耦合:模块间,仅交换数据
					控制耦合:交换控制信息.控制耦合在模块适当分解之后可以用数据耦合取代
					特征耦合:传递的是整个数据结构,但是需要的只是该数据结构中的一部分数据
					公共耦合:多模块通过公共数据环境相互作用[又存在两种形式:1.一个模块往公共区放数据,另一个模块从公共区取数据.这是特殊的数据耦合;2.模块们既往公共区放数据,也取数据.这种耦合介于数据耦合和控制耦合之间]
					内容耦合:
						一个模块访问另一个模块内部数据
						两个模块有一部分程序代码重叠
					原则:尽量使用数据耦合,少用控制耦合和特征耦合,限制公共环境耦合的范围,完全不用内容耦合
	启发规则:
		改进软件结构,提高模块独立性
		深度,宽度,扇出和扇入适当:
			宽度表示软件结构内同一个层次上模块总数的最大值
			扇出表示一个模块直接控制的模块数目:平均扇出3或4最佳
			扇入表明调用其的上级数
	面向数据流的设计方法
		信息流分为:
			交换流
			事务流:特点在于,处理根据输入数据的类型在若干个动作序列中选出一个来执行
		将数据流图映射成软件结构的方法:
			1.确保数据流图的处理精化
			2.确定数据流图是变换特性还是事务特性
			3.确定输入,输出,变换中心三部分,对应第一级分解的三个主模块
			4.从变换中心的边界逆向将每个处理映射成适当模块,作为第二级分解.
			5.各个模块做修改和合并
第六章 详细设计
	结构程序设计
		经典定义:程序的代码块仅仅通过顺序,选择和循环这3种基本控制结构进行连接,并且每个代码块只有一个入口和一个出口.
		较全面的定义:尽可能少用GOTO语句的程序设计方法.最好仅在检测出错误时才使用GOTO语句,而且总是受用前向GOTO语句
		除了三种基本控制结构,还能使用DO_CASE和DO_UNTIL循环结构设计,称为扩展的结构程序设计
		如果还能使用LEAVE(BREAK)结构,则称为修正的程序设计
	人机界面设计
		主要考虑:
			系统响应时间
				长度和易变性
			用户帮助设计
			出错信息处理
			命令交互
		设计过程:
			创建设计模型->建立原型->用户评估->修改
	过程设计的工具
		程序流程图
			主要缺点:
				诱使程序猿过早考虑控制细节,而不是全局结构
				滥用箭头表示的程序流会导致结构不当
				不易表示数据结构
		盒图
			特点:
				功能域明确
				不可能任意转移控制
				容易确定局部和全局数据的作用域
				容易表现嵌套关系和模块的层次结构
		PAD图
			优点:
				按照PAD设计出来的程序必然是结构化程序
				程序结构十分清晰
				容易将其转换成高级语言源程序
				即可描述程序逻辑,也可描绘数据结构
				支持自顶向下,逐步求精
		判定表
			四部分组成:
				左上:所有条件
				左下:所有可能做的动作
				右上:各种条件组合的一个矩阵
				右下:和每种条件组合相对应的动作
	程序复杂程度的定量度量
		McCabe方法
			复合条件要分解成若干个简单条件.每个简单条件对应流图中的一个节点,从每个判定节点中引出两条或多条边;一条路径上的多个节点被压缩成一个节点;
			计算环形复杂度
				流图中的区域数=环形复杂度
				流图G的环形复杂度 V(G) = E - N + 2;E是边的条数,N是节点数
				V(G) = P + 1;P是流图中判定节点的个数
			实践表明, V(G) <=10,比较合适
		Halstead方法
			程序长度N = 运算符出现次数N1 + 操作数出现次数N2
			预测程序长度:
				H = n1 * log2(n1) + n2 * log2(n2)
				n1 不同运算符(包括关键字)的个数;n2 不同操作数(变量和常数)的个数
			预测程序中包含的错误个数:
				E = N * log2(n1 + n2)/3000
第七章 实现
	编码和测试统称为实现
	编码:把软件设计结果翻译成用某种程序设计语言书写的程序;软件的质量合租要取决于软件设计的质量
	编码和单元测试属于软件生命周期的同一阶段,此阶段结束后,进行各种综合测试
	软件测试
		为了发现程序中的错误而执行程序的过程
		黑盒测试(功能测试):在程序接口进行的测试,只检查程序功能是否正常使用.
			等价划分,将程序输入域划分成若干数据类,取其代表元素
			边界值分析
		白盒测试(结构测试):按照程序内部的逻辑测试程序,检测程序中的主要执行同路是否都能按预定要求工作
			逻辑覆盖
				语句覆盖,使每个语句至少执行一次
				判定覆盖,每个判定分支都至少执行一次
				条件覆盖,使判定表达式中的每个条件都取到各种可能的结果,(注,各个条件取遍所有可能,并不说明复合表达式能取遍真假了,这是关键)
				判定/条件覆盖,判定覆盖不一定包含条件覆盖,条件覆盖不一定包括判定覆盖
				条件组合覆盖,使每个判定表达式中条件的各种可能组合都出现,满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到
				点覆盖,和语句覆盖标准相同
				边覆盖,和判定覆盖一致
				路径覆盖,每条可能的路径都至少执行一次
			控制结构测试
				基本路径测试
					计算环形复杂度,决定了有多少条独立路径
					使用深度搜索,如果某节点的所有后继都被搜索过,再搜索到这个节点的时候只用选择它的一条后继路径即可
	测试步骤:
		模块测试(单元测试),往往能发现编码和详细设计的错误
			主要使用白盒技术
			主要测试对象
				对通过模块接口的数据流,参数的数目,次序,属性或单位系统等
				局部数据结构
				重要执行通路
				出错处理通路
				边界条件
		子系统测试,发现模块间的协调和通信问题,着重测试模块的接口
			非渐增式测试
			渐增式测试
				自顶向下
				自底向上
				自顶向下优点是,不需要测试驱动程序,能够在测试阶段的早起实现并验证系统的主要功能,能在早期发现上层模块的接口错误;
				缺点是,需要存根程序
			回归测试,即集成了新的模块之后,重新执行之前某个测试的子集
		系统测试,验证系统能提供需求说明书中指定的功能.往往发现,软件设计中的错误,或需求说明中的错误
		验收测试(确认测试),在用户积极参与下,进行测试.
			Alpha测试,用户在开发场所进行,并在开发者指导下进行
			Beta测试,由软件的最终用户客户场所进行,不需要开发者在场
		平台运行
	软件可靠性
		可靠性,程序在给定时间间隔内,按照规格说明书的规定成功地运行的概率
		可用性,程序在给定的时间点,按照规格说明数的规定,成功运行的概率
第八章 维护
	软件已经交付使用后,为了改正错误或满足新的需要而修改软件的过程
	维护劳动分为生产性活动(分析评估,修改设计和编写程序代码)和非生产性活动(理解程序代码功能,解释数据结构,接口特点等)
	需要维护的有,组织,报告和事件流.这些都需要,软件设计,复查,必要的代码修改,单元测试和集成测试,验收测试和复审
	可维护性
		维护人员理解,改正,改动或改进这个软件的难易程度
		决定因素有:
			可理解性
			可测试性
			可修改性
			可重用性
		文档是影响软件可维护性的决定因素.
			用户文档,描述系统功能和使用方法
			系统文档,描述系统设计,实现和测试等内容
	软件再工程
		与发行维护的实质就是"软件再工程",分为以下步骤,仅表示相对顺序,不确定步骤起点
			库存目录分析
			文档重构
			逆向工程
			代码重构
			数据重构
			正向工程
第九章 面向对象方法学引论
	出发点和基本原则:使描述问题的问题空间(问题域)与实现解法的解空间(求解域)在结构上尽可能一致
	计算机中的实体称为解空间对象
	语义断层:问题空间中,对象的行为是复杂的,解空间中对象行为简单,只有借助十分复杂的算法,才能操纵解空间对象得到解
	要点:
		客观世界是由各种对象组成的,任何事物都是对象,复杂的对象可以由简单的对象组合而成
		所有对象都能被划分成各种对象类
		类之间可以继承
		对象彼此之间仅能通过船体消息互相交互
	区分:
		基于对象的方法:仅使用对象和消息
		基于类的方法:在上一步的基础上,将所有对象划分成类
		面向对象方法:同时使用对象,类,继承和消息的方法
	优点:
		与人类习惯思维方式一致
		稳定性好
		可重用性好
		较易开发大型软件产品
		可维护性好
	面向对象的概念
		对象是对问题域中某个实体的抽象,设立某个对象就反映了软件系统具有保存有关它的信息并且与它进行交互的能力
		特点:
			以数据为中心
			对象是主动的
			实现了数据封装
			具有并行性
			模块独立性好
		类是支持继承的抽象数据类型,而对象是类的实例
		实例,某个特定的类所描述的一个具体对象
		消息,要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明.由接收消息的对象,消息选择符,零个或多个变元组成.
		方法,对象所能执行的操作
		属性,类中定义的数据,是对客观世界实体所具有的性质的抽象
		封装,继承
		多态性,在运行时刻才根据接受消息决定执行哪个版本操作,属于动态联编/滞后联编
		重载,静态联编/先前联编
	面向对象建模
		三种模型:描述系统数据结构的对象模型,描述系统控制结构的动态模型,描述系统功能的功能模型
		类图(对象模型)
			定义类;属性:可见性分为3种:公有的,私有的和保护的,分别是'+','-'和'#'号;服务
			关联:
				普通关联
				关联角色
				限定关联
				关联类
			聚集:
				共享聚集
				组合聚集
			泛化:
				普通泛化
				受限泛化
			细化关系和依赖关系
		状态图(动态模型)
		用例图(功能模型)
			系统,用方框表示系统边界
			用例
			行为者
			用例之间的关系
				扩展关系:小用例指向大用例,表示一种可选的状态
				包含关系:大用例指向小用例,表示一种必然的过程
		三种模型之间的关系
			针对每个类建立的动态模型,描述了类实例的生命周期或运行周期
			状态转换驱使行为发生,行为在数据流图中被映射成处理,在用例图中被映射成用例,同时与类图中的服务相对应
			功能模型中的处理对应于对象模型中的类所提供的服务
			数据流图中的数据存储,数据源点/终点,通常是对象模型中的对象
第十章 面向对象分析
	OOA,抽取和整理用户需求并建立问题域精确模型的过程
	三个模型对应了三个系统要素:
		对象模型->静态结构
		动态模型->交互次序
		功能模型->数据变换
	对象模型通常由5个层次组成:
		主题层,类与对象层,结构层,属性层和服务层,对应的5项主要活动:
		识别主题,找出类和对象,识别结构,定义属性和服务;这5项工作没有严格的先后顺序
	建立对象模型
		步骤:
			确定对象类和关联,对于大型复杂问题还要进一步划分出若干个主题;
				关联应该描述问题域的静态结构,而不是一个瞬时事件
				划分主题不是按照功能,而是问题领域来划分:应尽量使不同主题内的对象相互依赖和交互最少
			给类和关联增添属性
				分析阶段不过多考虑属性;注意,如果是对象非公开的内部状态,是不能作为属性的
			利用适当的继承关系合并和组织类
			[动态模型和功能模型确定后才能确定类中操作]
	建立动态模型
		交互式系统中,动态模型非常重要
		过程:
			编写脚本;脚本,系统某一执行期间内出现的一系列事件;编写脚本的实质就是分析用户对系统交互行为的要求的过程
			设想用户界面
			画事件跟踪图(简化版的顺序图)
				确定事件
				画出事件跟踪图
			画状态图
			审查动态模型
	建立功能模型
		过程:
			画出基本系统模型图
			画出功能级数据流图
			描述处理框功能
	定义服务
第十一章 面向对象设计
	可细分为:系统设计和对象设计
	系统设计确定实现系统的策略和目标系统的高层结构
	对象设计确定解空间中的类,关联,接口形式及实现服务的算法
	对象设计原则
		模块化
		抽象
		信息隐藏
		低耦合,高内聚
		可重用
	软件重用
		知识重用
		方法和标准重用
		软件成分重用
			代码重用
			设计结果重用
			分析结果重用
		可被重用的软件成分:
			项目计划,成本估计,体系结构,需求模型,规格说明,设计,源代码,用户文档和技术文档,用户界面,数据,测试用例
		以类的形式实现重用有三种方式:实例重用,继承重用和多态重用
	系统分解
		面向对象设计模型逻辑上由四部分组成:问题域子系统,人机交互子系统,任务管理子系统和数据管理子系统
		子系统之间的交互方式有两种:客户-供应商关系(单向调用);平等伙伴(互相调用)
		组织子系统的两种方案
			层次组织,每层一个子系统,下层为上层提供服务
				封闭式:每层子系统仅仅使用其直接下层提供的服务
				开放式:每层子系统可以使用其任意下层的服务
			块状组织
				将软件系统垂直地分解成若干个相对独立,弱耦合的子系统,每块提供一种类型的服务
		设计问题域子系统
		设计人机交互子系统
			分类用户
			描述用户
			设计命令层次
			精化命令层次
			设计人机交互类
		设计任务管理子系统
			分析并发性
			设计任务管理子系统
				常见的任务有,事件驱动型任务,时钟驱动型任务,优先任务,关键任务和协调任务
		设计数据管理子系统
			选择数据存储管理模式
				文件管理系统
				关系数据库管理系统,缺点是;
					运行开销大
					不能满足高级应用的需求,常用与商务应用,很难用在数据类型丰富或操作不标准的应用中]
					与程序设计语言连接不自然
			设计数据管理相关服务
		设计类中服务
			功能模型指明了系统必须提供的服务
			如果处理影响或修改了一个对象,则应该把该处理和处理的目标联系在一起
	设计关联
	设计优化
		确定优先级
		增加冗余关联以提高访问效率
		调整查询次序
		保留派生属性